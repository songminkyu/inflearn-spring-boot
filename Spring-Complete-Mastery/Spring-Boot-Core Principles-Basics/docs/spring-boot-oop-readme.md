# 객체지향 스프링부트 (Object-Oriented Spring Boot)

## 목차
- [스프링 프레임워크 소개](#스프링-프레임워크-소개)
- [스프링의 역사](#스프링의-역사)
- [스프링의 핵심 기능](#스프링의-핵심-기능)
- [스프링 부트란?](#스프링-부트란)
- [객체지향 프로그래밍](#객체지향-프로그래밍)
- [다형성(Polymorphism)](#다형성polymorphism)
- [객체지향 설계의 5가지 원칙 (SOLID)](#객체지향-설계의-5가지-원칙-solid)
  - [단일 책임 원칙 (SRP)](#단일-책임-원칙-srp)
  - [개방-폐쇄 원칙 (OCP)](#개방-폐쇄-원칙-ocp)
  - [리스코프 치환 원칙 (LSP)](#리스코프-치환-원칙-lsp)
  - [인터페이스 분리 원칙 (ISP)](#인터페이스-분리-원칙-isp)
  - [의존관계 역전 원칙 (DIP)](#의존관계-역전-원칙-dip)
- [스프링과 객체지향](#스프링과-객체지향)
- [의존성 주입 (DI)](#의존성-주입-di)

## 스프링 프레임워크 소개

스프링 프레임워크는 2002년 EJB(Enterprise JavaBeans)의 복잡성과 높은 개발 비용(약 30,000달러)에 대한 대안으로 등장했습니다. 스프링은 BeanFactory, ApplicationContext, POJO(Plain Old Java Object) 기반의 경량 프레임워크로, 개발 생산성과 코드 품질을 향상시키는 솔루션을 제공합니다.

주요 창시자:
- Juergen Hoeller(독일)
- Yann Caroff(프랑스)

스프링은 기존 J2EE(EJB) 시스템의 복잡성을 해결하고자 탄생했습니다.

## 스프링의 역사

- **2003년**: 스프링 1.0 출시 - XML 기반 설정
- **2006년**: 스프링 2.0 출시 - XML 기반 설정 개선
- **2009년**: 스프링 3.0 출시 - 애너테이션 기반 설정 도입
- **2013년**: 스프링 4.0 출시 - Java 8 지원
- **2014년**: 스프링 부트 1.0 출시
- **2017년**: 스프링 5.0, 스프링 부트 2.0 출시 - 리액티브 프로그래밍 지원
- **2020년 9월**: 스프링 5.2.x, 스프링 부트 2.3.x 출시

## 스프링의 핵심 기능

스프링 프레임워크는 모듈화된 구조로 다양한 기능을 제공합니다:

- **핵심 기술**: DI 컨테이너, AOP, 이벤트, 리소스 등
- **웹 기술**: MVC, WebFlux 등
- **데이터 접근**: 트랜잭션, JDBC, ORM 지원, XML 처리
- **통합**: 원격 지원, JMS, 이메일, 스케줄링 등
- **테스트**: 스프링 테스트 프레임워크
- **언어**: 코틀린, 그루비 등 지원
- **기타**: Rest Docs 등

![스프링 모듈 구조](https://spring.io/img/spring-by-pivotal.png)

## 스프링 부트란?

스프링 부트는 스프링의 복잡한 설정을 간소화하고 빠르게 개발할 수 있게 해주는 프레임워크입니다:

- **자동 구성**: 복잡한 설정을 자동화
- **내장 서버**: Tomcat 등 내장
- **스타터 의존성**: 필요한 라이브러리를 쉽게 추가
- **3rd party 라이브러리 자동 구성**: 외부 라이브러리 통합 간소화
- **메트릭, 상태 확인, 외부 설정 등**: 운영 기능 제공

## 객체지향 프로그래밍

객체지향 프로그래밍은 이론이 아닌 실전에서 중요합니다. 객체지향의 핵심은 다음과 같은 질문에 답하는 것입니다:

- 왜 필요한가?
- 객체지향이란 무엇인가?
- 객체지향의 본질은 무엇인가?
- 객체지향을 실무에서 어떻게 적용할 수 있는가?

객체지향이 필요한 이유:
- 역할과 구현을 분리하여 유연하고 변경이 용이한 프로그램을 만들기 위함
- 다양한 요구사항 변경에 대응하기 위함
- 클라이언트 코드의 변경 없이 서버 측 구현을 바꿀 수 있게 함

## 다형성(Polymorphism)

다형성은 객체지향의 핵심 원리입니다:

- 역할과 구현을 분리하여 1:1 관계가 아닌 1:N 관계를 가능하게 함
- 클라이언트는 대상의 역할(인터페이스)만 알면 됨
- 클라이언트는 구현 대상의 내부 구조를 알 필요가 없음

![다형성 예시](https://www.plantuml.com/plantuml/png/SoWkIImgAStDuNBAJrBGjLDmpCbCJbMmKiX8pSd9vt98pKi1IW80)

예시:
- 운전자는 K3 자동차를 운전할 수 있음
- 운전자가 테슬라로 차를 바꿔도 운전할 수 있음
- 이처럼 역할과 구현을 분리하면 유연하고 변경이 용이한 프로그램을 만들 수 있음

다형성의 본질:
- 인터페이스를 구현한 객체 인스턴스를 실행 시점에 유연하게 변경할 수 있음
- 클라이언트를 변경하지 않고 서버의 구현 기능을 유연하게 변경할 수 있음

## 객체지향 설계의 5가지 원칙 (SOLID)

SOLID는 객체지향 설계의 5가지 기본 원칙을 의미합니다:

### 단일 책임 원칙 (SRP)
- Single Responsibility Principle
- 한 클래스는 하나의 책임만 가져야 함
- 변경이 있을 때 파급 효과가 적어야 함
- 예: UI 변경과 데이터베이스 로직 변경은 서로 영향을 미치지 않아야 함

### 개방-폐쇄 원칙 (OCP)
- Open/Closed Principle
- 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 함
- 기존 코드를 변경하지 않고 기능을 확장할 수 있어야 함

```java
// OCP를 위반하는 코드 예시
public class MemberService {
    // 변경 전
    private MemberRepository memberRepository = new MemoryMemberRepository();
    
    // 변경 후 - 코드 수정 필요
    // private MemberRepository memberRepository = new JdbcMemberRepository();
}
```

OCP를 지키기 위해서는 역할과 구현을 분리하고 객체를 생성하고 연관관계를 맺어주는 별도의 조립, 설정자가 필요합니다.

### 리스코프 치환 원칙 (LSP)
- Liskov Substitution Principle
- 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 함
- 예: 자동차 인터페이스의 엑셀은 앞으로 가도록 구현해야 함 (뒤로 가게 구현하면 LSP 위반)

### 인터페이스 분리 원칙 (ISP)
- Interface Segregation Principle
- 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다
- 자동차 인터페이스 -> 운전 인터페이스, 정비 인터페이스로 분리
- 사용자 인터페이스 -> 운전자 인터페이스, 정비사 인터페이스로 분리
- 인터페이스가 명확해지고, 대체 가능성이 높아짐

### 의존관계 역전 원칙 (DIP)
- Dependency Inversion Principle
- "추상화에 의존해야지, 구체화에 의존하면 안된다."
- 구현 클래스에 의존하지 말고, 인터페이스에 의존해야 함
- 역할(Role)에 의존해야 함

```java
// DIP를 위반하는 코드
public class MemberService {
    // 인터페이스(MemberRepository)에도 의존하고
    // 구현 클래스(MemoryMemberRepository)에도 의존함
    private MemberRepository memberRepository = new MemoryMemberRepository();
}
```

## 스프링과 객체지향

스프링은 다음과 같은 방식으로 객체지향 설계 원칙을 지원합니다:

- DI(의존성 주입) 컨테이너를 통해 다형성을 극대화
- OCP, DIP 원칙을 지키도록 지원
- 클라이언트 코드의 변경 없이 기능 확장 가능

## 의존성 주입 (DI)

스프링은 의존성 주입을 통해 OCP와 DIP 원칙을 지키도록 도와줍니다:

- 애플리케이션 실행 시점에 필요한 객체를 생성
- 생성자를 통해 의존관계를 주입
- 객체는 의존관계를 직접 생성하지 않고 외부에서 주입받음

이러한 방식은 객체지향 설계를 실현하고 코드 유지보수성을 크게 향상시킵니다.

```java
// DI를 적용한 코드
public class MemberService {
    private final MemberRepository memberRepository;
    
    public MemberService(MemberRepository memberRepository) {
        this.memberRepository = memberRepository;
    }
}
```

스프링은 다음과 같은 방식으로 객체지향 프로그래밍을 지원합니다:
- 모든 설계에 인터페이스를 부여
- 컴포넌트 스캔과 자동 주입을 통한 편리한 DI 지원
- 설정 정보를 통해 의존관계 주입을 외부에서 관리
